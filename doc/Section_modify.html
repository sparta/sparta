<HTML>
<CENTER><A HREF = "Section_tools.html">Previous Section</A> - <A HREF = "http://sparta.sandia.gov">SPARTA WWW Site</A> -
<A HREF = "Manual.html">SPARTA Documentation</A> - <A HREF = "Section_commands.html#comm">SPARTA Commands</A> - <A HREF = "Section_python.html">Next
Section</A> 
</CENTER>






<HR>

<H3>8. Modifying & extending SPARTA 
</H3>
<P>This section describes how to extend SPARTA by modifying its source code.
</P>
8.1 <A HREF = "#mod_1">Compute styles</A><BR>
8.2 <A HREF = "#mod_2">Fix styles</A><BR>
8.3 <A HREF = "#mod_3">Region styles</A><BR>
8.4 <A HREF = "#mod_4">Collision styles</A><BR>
8.5 <A HREF = "#mod_5">Surface collision styles</A><BR>
8.6 <A HREF = "#mod_6">Chemistry styles</A><BR>
8.7 <A HREF = "#mod_7">Dump styles</A><BR>
8.8 <A HREF = "#mod_8">Input script commands</A> <BR>

<P>SPARTA is designed in a modular fashion so as to be easy to modify and
extend with new functionality.
</P>
<P>In this section, changes and additions users can make are listed along
with minimal instructions.  If you add a new feature to SPARTA and
think it will be of general interest to users, please submit it to the
developers for inclusion in the released version of SPARTA.
</P>
<P>The best way to add a new feature is to find a similar feature in
SPARTA and look at the corresponding source and header files to figure
out what it does. You will need some knowledge of C++ to be able to
understand the hi-level structure of SPARTA and its class
organization, but functions (class methods) that do actual
computations are written in vanilla C-style code and operate on simple
C-style data structures (vectors, arrays, structs).
</P>
<P>The new features described in this section require you to write a new
C++ derived class. Creating a new class requires 2 files, a source
code file (*.cpp) and a header file (*.h).  The derived class must
provide certain methods to work as a new option.  Depending on how
different your new feature is compared to existing features, you can
either derive from the base class itself, or from a derived class that
already exists.  Enabling SPARTA to invoke the new class is as simple
as putting the two source files in the src dir and re-building SPARTA.
</P>
<P>The advantage of C++ and its object-orientation is that all the code
and variables needed to define the new feature are in the 2 files you
write, and thus shouldn't make the rest of SPARTA more complex or
cause side-effect bugs.
</P>
<P>Here is a concrete example. Suppose you write 2 files collide_foo.cpp
and collide_foo.h that define a new class CollideFoo that computes
inter-particle collisions described in the classic 1997 paper by Foo,
et al. If you wish to invoke those potentials in a SPARTA input script
with a command like
</P>
<P>collide foo mix-ID params.foo 3.0
</P>
<P>then your collide_foo.h file should be structured as follows:
</P>
<P>#ifdef COLLIDE_CLASS
CollideStyle(foo,CollideFoo)
#else
...
(class definition for CollideFoo)
...
#endif 
</P>
<P>where "foo" is the style keyword in the collid command, and CollideFoo
is the class name defined in your collide_foo.cpp and collide_foo.h
files.
</P>
<P>When you re-build SPARTA, your new collision model becomes part of the
executable and can be invoked with a <A HREF = "collide.html">collide</A> command
like the example above.  Arguments like a mixture ID, params.foo (a
file with collision parameters), and 3.0 can be defined and processed
by your new class.
</P>
<P>As illustrated by this example, many kinds of options are referred to
in the SPARTA documentation as the "style" of a particular command.
</P>
<P>The instructions below give the header file for the base class that
these styles are derived from.  Public variables in that file are ones
used and set by the derived classes which are also used by the base
class.  Sometimes they are also used by the rest of SPARTA.  Virtual
functions in the base class header file which are set = 0 are ones
that must be defined in the new derived class to give it the
functionality SPARTA expects.  Virtual functions that are not set to 0
are functions that can be optionally defined.
</P>
<P>Here are additional guidelines for modifying SPARTA and adding new
functionality:
</P>
<UL><LI>Think about whether what you want to do would be better as a pre- or
post-processing step. Many computations are more easily and more
quickly done that way. 

<LI>Don't do anything within the timestepping of a run that isn't
parallel.  E.g. don't accumulate a large volume of data on a single
processor and analyze it.  This runs the risk of seriously degrading
the parallel efficiency. 

<P>If you have a question about how to compute something or about
internal SPARTA data structures or algorithms, feel free to
send an email to the developers.
</P>
<LI>If you add something you think is generally useful, also send an email
to the developers. We might be interested in adding it to the SPARTA
distribution. 
</UL>
<HR>

<HR>

<A NAME = "mod_1"></A><H4>8.1 Compute styles 
</H4>
<HR>

<P><A HREF = "compute.html">Compute style commands</A> calculate instantaneous
properties of the simulated system.  They can be global properties, or
per particle or per grid cell or per surface element properties.  The
result can be single value or multiple values (global or per particle
or per grid or per surf).
</P>
<P>Here is a brief description of methods to define in a new derived
class.  See compute.h for details.  All of these methods are optional.
</P>
<DIV ALIGN=center><TABLE  BORDER=1 >
<TR><TD >init</TD><TD > initialization before a run</TD></TR>
<TR><TD >compute_scalar</TD><TD > compute a global scalar quantity</TD></TR>
<TR><TD >compute_vector</TD><TD > compute a global vector of quantities</TD></TR>
<TR><TD >compute_per_particle</TD><TD > compute one or more quantities per particle</TD></TR>
<TR><TD >compute_per_grid</TD><TD > compute one or more quantities per grid cell</TD></TR>
<TR><TD >compute_per_surf</TD><TD > compute one or more quantities per surface element</TD></TR>
<TR><TD >surf_tally</TD><TD > call when a particle hits a surface element</TD></TR>
<TR><TD >boundary_tally</TD><TD > call when a particle hits a simulation box boundary</TD></TR>
<TR><TD >memory_usage</TD><TD > tally memory usage 
</TD></TR></TABLE></DIV>

<A NAME = "mod_2"></A><H4>8.2 Fix styles 
</H4>
<P><A HREF = "fix.html">Fix style commands</A> perform operations during the
timestepping loop of a simulation.  They define methods which are
invoked at different points within the timestep.  They can be used to
insert particles, perform load-balancing, or perform time-averaging of
various quantities.  They can also produce output of various kinds,
similar to <A HREF = "compute.html">compute</A> commands.
</P>
<P>Here is a brief description of methods to define in a new derived
class.  See compute.h for details.  All of these methods, except
setmask(), are optional.
</P>
<DIV ALIGN=center><TABLE  BORDER=1 >
<TR><TD >setmask</TD><TD > set flags that determine when the fix is called within a timestep</TD></TR>
<TR><TD >init</TD><TD > initialization before a run</TD></TR>
<TR><TD >start_of_step</TD><TD > called at beginning of timestep</TD></TR>
<TR><TD >end_of_step</TD><TD > called at end of timestep</TD></TR>
<TR><TD >memory_usage</TD><TD > tally memory usage 
</TD></TR></TABLE></DIV>

<HR>

<A NAME = "mod_3"></A><H4>8.3 Region styles 
</H4>
<HR>

<A NAME = "mod_4"></A><H4>8.4 Collision styles 
</H4>
<HR>

<A NAME = "mod_5"></A><H4>8.5 Surface collision styles 
</H4>
<HR>

<A NAME = "mod_6"></A><H4>8.6 Chemistry styles 
</H4>
<HR>

<A NAME = "mod_7"></A><H4>8.7 Dump styles 
</H4>
<HR>

<A NAME = "mod_8"></A><H4>8.8 Input script commands 
</H4>
</HTML>
